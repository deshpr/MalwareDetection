import warnings
import numpy as np
import pandas as pd
import pickle
import dill
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
import os
#Donot modify the method signatures and return dtypes
#you can include additional functions of your choice
import dask as dd





class MalwareDetectionModel:
    def __init__(self):
        self.dtypes = {
                'MachineIdentifier':'category',
                'ProductName':'category',
                'EngineVersion':'category',
                'AppVersion':'category',
                'AvSigVersion':'category', 
                'IsBeta':'category', 
                'RtpStateBitfield':'float64',
                'IsSxsPassiveMode':'float64',
                'DefaultBrowsersIdentifier':'float64',
                'AVProductStatesIdentifier':'float64',
                'AVProductsInstalled':'float64',
                'AVProductsEnabled':'float64',
                'HasTpm':'float64',
                'CountryIdentifier':'float64',
                'CityIdentifier':'category',
                'OrganizationIdentifier':'float64',
                'GeoNameIdentifier':'float64',
                'LocaleEnglishNameIdentifier ':'float64',
                'Platform ':'category',
                'Processor':'category',
                'OsVer':'category',
                'OsBuild':'category',
                'OsSuite':'category',
                'OsPlatformSubRelease':'category',
                'OsBuildLab':'category', 
                'SkuEdition':'category',
                'IsProtected':'float64',
                'AutoSampleOptIn':'float64',
                'PuaMode':'category',
                'SMode':'float64',
                'IeVerIdentifier':'float64',
                'SmartScreen':'category',
                'Firewall':'float64',
                'UacLuaenable':'float64',
                'Census_MDC2FormFactor':'category',
                'Census_DeviceFamily':'category',
                'Census_OEMNameIdentifier':'float64',
                'Census_OEMModelIdentifier':'float64',
                'Census_ProcessorCoreCount':'float64', 
                'Census_ProcessorManufacturerIdentifier':'float64',
                'Census_ProcessorModelIdentifier':'float64',
                'Census_ProcessorClass':'category',
                'Census_PrimaryDiskTotalCapacity':'float64',
                'Census_PrimaryDiskTypeName':'category',
                'Census_SystemVolumeTotalCapacity':'float64', 
                'Census_HasOpticalDiskDrive':'float64',
                'Census_TotalPhysicalRAM':'float64',
                'Census_ChassisTypeName':'category',
                'Census_InternalPrimaryDiagonalDisplaySizeInInches':'float64',
                'Census_InternalPrimaryDisplayResolutionHorizontal':'float64',
                'Census_InternalPrimaryDisplayResolutionVertical':'float64',
                'Census_PowerPlatformRoleName':'category',
                'Census_InternalBatteryType':'category',
                'Census_InternalBatteryNumberOfCharges':'float64',
                'Census_OSVersion':'category',
                'Census_OSArchitecture':'category',
                'Census_OSBranch':'category',
                'Census_OSBuildNumber':'float64',
                'Census_OSBuildRevision':'float64',
                'Census_OSEdition':'category',
                'Census_OSSkuName':'category',
                'Census_OSInstallTypeName':'category',
                'Census_OSInstallLanguageIdentifier':'float64',
                'Census_OSUILocaleIdentifier':'float64',
                'Census_OSWUAutoUpdateOptionsName':'category',
                'Census_IsPortableOperatingSystem':'float64',
                'Census_GenuineStateName':'category',
                'Census_ActivationChannel':'category',
                'Census_IsFlightingInternal':'float64',
                'Census_IsFlightsDisabled':'float64', 
                'Census_FlightRing':'category',
                'Census_ThresholdOptIn':'float64',
                'Census_FirmwareManufacturerIdentifier':'float64',
                'Census_FirmwareVersionIdentifier':'float64',
                'Census_IsSecureBootEnabled':'float64',
                'Census_IsWIMBootEnabled':'float64',
                'Census_IsVirtualDevice':'float64',
                'Census_IsTouchEnabled':'float64',
                'Census_IsPenCapable':'float64',
                'Census_IsAlwaysOnAlwaysConnectedCapable':'float64',
                'Wdft_IsGamer':'float64',
                'Wdft_RegionIdentifier':'float64',
                'HasDetections':'float64'               
                }
        
        self.classifier = None

    def preProcessing(self, fileName):
        # remove too much data for now.
        print("procssinfg the file: {}".format(fileName))
        import dask.dataframe as dd
        data = dd.read_csv(fileName, dtype=self.dtypes, na_values=[''])   
        topRows = data.head(10000000)
        print("got the first milllion")
        currentDirectory = os.getcwd()
        outputfile = os.path.join(currentDirectory, "output_frame.csv")
        topRows.to_csv(outputfile)
        print("dfone")
        return topRows


    def transformData(self, inputData):
        print("get input data")
        
        # change ProductName

        inputData['ProductName'] = inputData['ProductName'].astype('category')#pd.Categorical(inputData['ProductName'])
        inputData['EngineVersion'] = inputData['EngineVersion'].astype('category')
        inputData['AppVersion'] = inputData['AppVersion'].astype('category')        
        inputData['AvSigVersion'] = inputData['AvSigVersion'].astype('category')
        inputData['Platform'] = inputData['Platform'].astype('category')
        inputData['Processor'] = inputData['Processor'].astype('category')
        inputData['OsVer'] = inputData['OsVer'].astype('category')
        inputData['OsPlatformSubRelease'] = inputData['OsPlatformSubRelease'].astype('category')
        inputData['OsBuildLab'] = inputData['OsBuildLab'].astype('category')
        inputData['SkuEdition'] = inputData['SkuEdition'].astype('category')
        inputData['SmartScreen'] = inputData['SmartScreen'].astype('category')
        inputData['Census_MDC2FormFactor'] = inputData['Census_MDC2FormFactor'].astype('category')
        inputData['Census_DeviceFamily'] = inputData['Census_DeviceFamily'].astype('category')
        inputData['Census_PrimaryDiskTypeName'] = inputData['Census_PrimaryDiskTypeName'].astype('category')
        inputData['Census_ChassisTypeName'] = inputData['Census_ChassisTypeName'].astype('category')
        inputData['Census_PowerPlatformRoleName'] = inputData['Census_PowerPlatformRoleName'].astype('category')
        inputData['Census_ChassisTypeName'] = inputData['Census_ChassisTypeName'].astype('category')
        inputData['Census_InternalBatteryType'] = inputData['Census_InternalBatteryType'].astype('category')
        inputData['Census_OSVersion'] = inputData['Census_OSVersion'].astype('category')
        inputData['Census_OSArchitecture'] = inputData['Census_ChassisTypeName'].astype('category')
        inputData['Census_OSBranch'] = inputData['Census_OSBranch'].astype('category')
        inputData['Census_OSEdition'] = inputData['Census_ChassisTypeName'].astype('category')
        inputData['Census_OSSkuName'] = inputData['Census_ChassisTypeName'].astype('category')
        inputData['Census_OSWUAutoUpdateOptionsName'] = inputData['Census_OSWUAutoUpdateOptionsName'].astype('category')
        inputData['Census_GenuineStateName'] = inputData['Census_GenuineStateName'].astype('category')
        inputData['Census_ActivationChannel'] = inputData['Census_ActivationChannel'].astype('category')
        inputData['Census_OSInstallTypeName'] = inputData['Census_OSInstallTypeName'].astype('category')
        inputData['Census_FlightRing'] = inputData['Census_FlightRing'].astype('category')
        inputData['Census_ProcessorClass'] = inputData['Census_ProcessorClass'].astype('category')
        
        cat_columns = inputData.select_dtypes(['category']).columns

        inputData[cat_columns] = inputData[cat_columns].apply(lambda x: x.cat.codes)

        inputData = inputData.fillna(inputData.mean())

        #inputData['ProductName'] = inputData[['ProductName']].apply(lambda x: x.cat.codes)
#        inputData['ProductName'] = inputData['ProductName'].cat.codes
#        print("category codes = {}".format(inputData['ProductName'].cat.codes))
        return inputData

    def returnFeatureAndOutput(self, inputData):
        columnCount = len(self.dtypes)
        cols = [col for col in inputData.columns if col != 'HasDetections']

        all_inputs = inputData.ix[:, cols].values
        print("returning data for {} columns".format(len(cols)))
        #        all_inputs = inputData[:, 0:columnCount - 1].values
        print("get class data")
        all_labels = inputData['HasDetections'].values
        return all_inputs, all_labels

    #trains a model, you can access the malware_train.csv file for training your model
    def train(self):
        currentDirectory = os.getcwd()
        fileName = os.path.join(currentDirectory, "data//malware_train.csv")
        print('Train Model')
        # Preprocessing of data

        inputData = self.preProcessing(fileName)
        print(len(inputData.columns))
        inputData = self.transformData(inputData)
        print(len(inputData.columns))

        all_inputs, all_labels = self.returnFeatureAndOutput(inputData)

        print("input data count = {}".format(len(all_inputs)))
        print("labels count = {} ".format(len(all_labels)))
        (training_inputs,
        testing_inputs,
        training_classes,
        testing_classes) = train_test_split(all_inputs, all_labels, test_size=0.25, random_state=1)
        # Create the classifier
        print(training_inputs)

        decision_tree_classifier = DecisionTreeClassifier()

        # Train the classifier on the training set
        decision_tree_classifier.fit(training_inputs, training_classes)
        # Validate the classifier on the testing set using classification accuracy
        print("Score = {}".format(decision_tree_classifier.score(testing_inputs, testing_classes)))

        self.classifier = decision_tree_classifier

        print("Perform prediction..")
        firstRow = inputData[0:1]
        print(firstRow)
        print(type(firstRow))
        firstRow.to_csv("testingData.csv", index = False)
        firstRow = firstRow.drop('HasDetections', axis=1)
        print(firstRow)
        """
        firstRow = inputData.iloc[1]
        print("first rtow...")

        print(firstRow)
        print(type(firstRow))
        firstRow = firstRow.to_frame()
        print(type(firstRow))
        firstRow = firstRow.drop('HasDetections', axis=1)
        """
        self.predict_probablities(firstRow)

    #predicts the probablity of a machine affected by malware. The input test_data is a pandas dataframe.
    #This function must return the predicted probabilities for the test machines
    def predict_probablities(self, test_data):
        print('Predict malware')
        print(type(test_data))
        print(test_data)
        copy = dict(test_data)
        print("column count = {}".format(len(test_data.columns)))
        # remove the output key
        test_data = self.transformData(test_data)
        cols = [col for col in test_data.columns if col != 'HasDetections']
        print("get all inputs")
        all_inputs = test_data.ix[:, cols].values
        print("predict...")
        predictions = self.classifier.predict(all_inputs)
        print("prediction = {}".format(predictions))
        return predictions



#calls the train function and saves the model_file
#donot modify the contents
if __name__ == "__main__":
    detectionModel = MalwareDetectionModel()
    detectionModel.train()
    filename = 'malwaremodel.pkl'
    f = open(filename, 'wb')
    dill.dump(detectionModel, f)
    f.close()
